+++
title = '브라우저가 웹페이지에서 렌더링되는 과정'
date = 2024-01-08T20:30:35+09:00
draft = false
tags = ['브라우저']
+++

![](https://velog.velcdn.com/images/greysu1/post/16e14783-8aa5-4527-9387-23ef264dc553/image.png)

## 브라우저가 동작하는 과정

브라우저 종류는 크롬부터 엣지, 사파리, 파이어폭스, 오페라 등 다양하게 있는데
각 브라우저의 렌더링 방식 중 세부사항은 조금씩 다를 수 있지만
웹 표준을 따르기 때문에 큰 틀은 유사하다고 한다.


## 브라우저 기본 구조
1. 사용자 인터페이스 - 위 주소 표시줄, 버튼, 북마크 등 페이지 보여주는 창을 제외한 나머지 부분
2. 브라우저 엔진 - 사용자 인터페이스와 렌더링 엔진 사이의 동작을 제어
3. 통신 - http요청과 같은 네트워크 호출에 사용
4. UI 백엔드 - 콤보 박스나 창같은 기본적인 장치를 그림
5. **자바스크립트 해석기** - 자바스크립트 코드를 해석 및 실행
6. 자료 저장소 - 자료를 저장(웹 데이터베이스)
![](https://velog.velcdn.com/images/greysu1/post/0b7ea253-0b55-4ab4-8e77-36d6e18128e0/image.png)


<br><br>
### 브라우저의 엔진
1. 렌더링 엔진: 사용자에게 보여지는 화면을 출력
2. 자바스크립트 엔진: 자바스크립트 코드를 읽고 기능을 작동
![](https://velog.velcdn.com/images/greysu1/post/41a22140-33b5-4897-a095-29e6c6146bd4/image.png)

### 1. HTML파싱 및 DOM생성
문자열로 이루어진 html문서를
브라우저가 이해하고 실행시키기 위해서는 변환과정이 필요하다.<br>
1) html파일을 바이트로 메모리에 저장한다.
2) 해당 문서의 인코딩방식을 기준으로 문자를 변환한다.
3) 문법적으로 최소한의 언어요소인 토큰으로 분해한다.
4) 토큰을 객체로 변환하여 기초적인 단위인 노드(node)를 생성한다.
5) 각 태그들의 부모 자식관계를 반영해 트리 자료구조로 구성한다.

_문서를 가져와서 분해하고 구조생성한 자료구조 형태의 결과물을 DOM이라고 한다._


### 2. CSS파싱 및 CSSOM생성
위에서부터 한 줄씩 DOM을 생성하다가 link, style태그를 만나면 DOM생성을 일시 중단한다.
그리고 CSS파일을 서버에 요청하고 응답받은 css파일도 CSSOM을 생성한다.
CSS파싱이 끝나면 일시 중단했던 HTML파싱으로 돌아가 재 파싱을 진행한다.

### 3. DOM과 CSSOM의 렌더트리 결합
![](https://velog.velcdn.com/images/greysu1/post/b009d0e2-121c-424e-bcce-62063a45820d/image.png)
렌더트리는 레이아웃을 계산하고 브라우저 환면에 렌더링되는 노드만으로 구성된다.

### 4. 자바스크립트 파싱
자바스크립트 코드가 들어있는 script태그나 link태그를 만나면 css때와 마찬가지로
DOM생성을 일시 중단하고 자바스크립트 코드를 파싱하는데 이때 렌더링 엔진이
자바스크립트 엔진에게 제어권을 넘긴다.(blocking이 일어났다고 표현)
이 후 자바스크립트 파싱 및 실행이 끝나면 다시 렌더링 엔진에게 제어권이 돌아가고
DOM생성을 제개한다.
*로딩 속도를 고려해script태그는 body태그 최하단에 위치하는 것이 좋다.
(다만, 자바스크립트 파일에 의존적인 페이지인 경우 불완전한 페이지를 출력한 수 있다.)






---
참고
https://d2.naver.com/helloworld/59361<br><br>
https://oliviakim.tistory.com/80
